#include <stdio.h>
#include <varargs.h>
#ifdef MSDOS
#include <dos.h>
#endif
static char curses_vers[] = "@(#) CURSES version 0.1 PRERELEASE 10/22/87";
static char curses_cpyw[] = "@(#) Copyright 1987 Edwin R. Carp";

/* #define EXPDATE ~568022341L  expires 12/31/87 at 23:01 */
#define EXPDATE ~999999999L

/*
 * curses for MSDOS - added UNIX functionality 08/22/92
 * 
 * This code was written by Edwin R. Carp (except for scanw/wscanw)
 * 
 * Written 10/06/87.
 * 
 * This code compiles under Microsoft C 3.0 and higher rev compilers, as well as
 * the Microsoft Quick C compiler (version 1.0 and higher).  To compile under
 * Borland's Turbo C compiler, you need to change the varargs stuff in
 * printw.
 * 
 * The UNIX version of this code is designed to work with the GNU termcap
 * package (available from prep.ai.mit.edu:/pub/gnu).
 * 
 * Functions supported:
 * 
 * Output Functions:
 * 
 * waddch, waddstr, box*, wclear, clearok, wclearbot, wclrtoeol, wdelch, werase,
 * winsch, wmove, nl, nonl, wprintw, wrefresh, wstandout, wstandend
 * wdeleteln, winsertln
 * 
 * Input functions:
 * 
 * echo, noecho, wgetch, wgetstr, wscanw
 * 
 * Miscellaneous Functions:
 * 
 * delwin, endwin, getyx, winch, initscr, leaveok, longname, newwin, scrollok,
 * touchwin, mvcur
 * 
 * NEW ROUTINES:
 * 
 * switchsc(), color(), wcolor()
 * 
 * NOTES:
 * 
 * the box() function has been expanded.  See curses.h for details.
 * 
 * scrollok() will set the _scroll flag, but it will be ignored. Scrolling is
 * not allowed.
 * 
 * longname() returns "vt100".
 * 
 * getch() calls the Microsoft getch() routine.
 * 
 * clear() and erase() never send the clear-screen sequence, since ansi.sys is
 * not supported.
 * 
 * Unsupported functions:
 * 
 * subwin()
 * 
 * THINGS TO DO:
 * 
 * 1.  Add real SysV stuff, like attrset(), etc.
 * 
 * 2.  Someday, port this mess to *NIX.  Have to add "character changed" logic,
 * rather than "line changed" logic, etc.  Do the termcap/terminfo stuff,
 * too.  This code is (sort of) optimized for MSDOS right now.
 * 
 * This isn't really as hard as it might look.  The routines initscr(), getch(),
 * refresh(), mvcur(), and endwin() are MS-DOS-optimized, and need to be
 * changed for UNIX termcap/terminfo support.
 * 
 * 3.  Steal subwin from the BSD curses stuff.  :)
 */

/*
 * psuedo functions for standard screen
 */

#define   addch(ch)             waddch(stdscr, ch)
#define   addstr(str)           waddstr(stdscr, str)
#define   clear()               wclear(stdscr)
#define   clrtobot()            wclrtobot(stdscr)
#define   clrtoeol()            wclrtoeol(stdscr)
#define   color(f, b, rf, rb)   wcolor(stdscr, f, b, rf, rb)
#define   deleteln()            wdeleteln(stdscr)
#define   erase()               werase(stdscr)
#define   getstr(str)           wgetstr(stdscr, str)
#define   inch()                winch(stdscr)
#define   insertln()            winsertln(stdscr)
#define   move(y, x)            wmove(stdscr, y, x)
#define   refresh()             wrefresh(stdscr)
#define   standout()            wstandout(stdscr)
#define   standend()            wstandend(stdscr)

/*
 * mv functions
 */

#define mvwaddch(win,y,x,ch) (wmove(win,y,x)==ERR?ERR:waddch(win,ch))
#define mvwgetch(win,y,x) (wmove(win,y,x)==ERR?ERR:wgetch(win))
#define mvwaddstr(win,y,x,s) (wmove(win,y,x)==ERR?ERR:waddstr(win,s))
#define mvwgetstr(win,y,x,s) (wmove(win,y,x)==ERR?ERR:wgetstr(win,s))
#define mvwinch(win,y,x) (wmove(win,y,x)==ERR?ERR:winch(win))
#define mvaddch(y,x,ch) mvwaddch(stdscr,y,x,ch)
#define mvgetch(y,x) mvwgetch(stdscr,y,x)
#define mvaddstr(y,x,str) mvwaddstr(stdscr,y,x,str)
#define mvgetstr(y,x,str) mvwgetstr(stdscr,y,x,str)
#define mvinch(y,x) mvwinch(stdscr,y,x)

/*
 * miscellaneous defines
 */
#define echo() ECHOSW=1
#define noecho() ECHOSW=0
#define nl() NEWMAP=1
#define nonl() NEWMAP=0
#define isdigit(ch) (ch >= '0' && ch <= '9')
#define iswhite(ch) (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r')

/*
 * termcap routine defines
 */

char *tgetstr (), *getenv ();

#undef putchar

#ifdef __POSIX_TERMIOS
#define raw()	 (_tty.c_lflag&=~(ICANON|ISIG),\
	_pfast=_rawmode=TRUE, tcsetattr(_tty_ch, TCSANOW, &_tty))

#define noraw()	 (_tty.c_lflag|=ISIG,_rawmode=FALSE,\
	_pfast=(_tty.c_iflag&ICRNL),tcsetattr(_tty_ch, TCSANOW, &_tty))

/* cbreak is like raw, but without turning off signals. */

#define cbreak() (_tty.c_lflag&=~ICANON, \
	_rawmode = TRUE, tcsetattr(_tty_ch, TCSANOW, &_tty))

#define nocbreak() (_tty.c_lflag |= ICANON, _tty.c_lflag &= ~ISIG, \
	_rawmode=FALSE, tcsetattr(_tty_ch, TCSANOW, &_tty))

#define crmode() cbreak()	/* backwards compatability */
#define nocrmode() nocbreak()	/* backwards compatability */

/*
#define echo()	 (_tty.c_lflag |= ECHO, _echoit = TRUE, \
	tcsetattr(_tty_ch, TCSADRAIN, &_tty))
#define noecho() (_tty.c_lflag &= ~ECHO, _echoit = FALSE, \
	tcsetattr(_tty_ch, TCSADRAIN, &_tty))
#define nl()	 (_tty.c_iflag |= ICRNL,_pfast = _rawmode, \
	tcsetattr(_tty_ch, TCSANOW, &_tty))
#define nonl()	 (_tty.c_iflag &= ~ICRNL, _pfast = TRUE, \
	tcsetattr(_tty_ch, TCSANOW, &_tty))
*/
#define	savetty() ((void) tcgetattr(_tty_ch, &_tty), \
	_res_iflg = _tty.c_iflag, _res_lflg = _tty.c_lflag)
#define	resetty() (_tty.c_iflag = _res_iflg, _tty.c_lflag = _res_lflg,\
	_echoit = ((_res_lflg & ECHO) == ECHO), \
	_rawmode = ((_res_lflg & (ISIG|ICANON)) != 0), \
	_pfast = ((_res_iflg & ICRNL) ? _rawmode : TRUE), \
	(void) tcsetattr(_tty_ch, TCSADRAIN, &_tty))

#define	erasechar()	(_tty.c_cc[VERASE])
#define	killchar()	(_tty.c_cc[VKILL])
#define baudrate()	(cfgetospeed(&_tty))
#else
#define raw()	 (_tty.sg_flags|=RAW, _pfast=_rawmode=TRUE, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
#define noraw()	 (_tty.sg_flags&=~RAW,_rawmode=FALSE,\
	_pfast=!(_tty.sg_flags&CRMOD),ioctl(_tty_ch, TIOCSETP, &_tty))
#define cbreak() (_tty.sg_flags |= CBREAK, _rawmode = TRUE, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
#define nocbreak() (_tty.sg_flags &= ~CBREAK,_rawmode=FALSE, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
#define crmode() cbreak()	/* backwards compatability */
#define nocrmode() nocbreak()	/* backwards compatability */
/*
#define echo()	 (_tty.sg_flags |= ECHO, _echoit = TRUE, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
#define noecho() (_tty.sg_flags &= ~ECHO, _echoit = FALSE, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
#define nl()	 (_tty.sg_flags |= CRMOD,_pfast = _rawmode, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
#define nonl()	 (_tty.sg_flags &= ~CRMOD, _pfast = TRUE, \
	ioctl(_tty_ch, TIOCSETP, &_tty))
*/
#define	savetty() ((void) ioctl(_tty_ch, TIOCGETP, &_tty), \
	_res_flg = _tty.sg_flags)
#define	resetty() (_tty.sg_flags = _res_flg, \
	_echoit = ((_res_flg & ECHO) == ECHO), \
	_rawmode = ((_res_flg & (CBREAK|RAW)) != 0), \
	_pfast = ((_res_flg & CRMOD) ? _rawmode : TRUE), \
	(void) ioctl(_tty_ch, TIOCSETP, &_tty))

#define	erasechar()	(_tty.sg_erase)
#define	killchar()	(_tty.sg_kill)
#define baudrate()	(_tty.sg_ospeed)
#endif
/*
 * variable defs follow
 * 
 */

/*
 * box codes: 0=do what the user wants, 1=non-graphics, 2=single-line,
 * 3=double-line, 4=solid-line
 */
char cur_box = 3;		/* double line boxes */
int ECHOSW = 1;			/* echo characters to the screen */
int NEWMAP = 1;			/* newline mapping on */

#define _count 4096		/* number of bytes per screen */
unsigned _wind0;		/* address of window 0 */
int _curwin = 0;		/* current writing window, 0-3 */
int _retrace = 0;		/* 1=wait for retrace, 0=don't wait (faster) */

#ifndef WINDOW

#define   bool   char
#define   reg   register

#define   TRUE   (1)
#define   FALSE   (0)
#define   ERR   (0)
#define   OK   (1)

#define   _ENDLINE   001
#define   _FULLWIN   002
#define   _SCROLLWIN   004
#define   _FLUSH      010
#define   _SUBWIN     020
#define   _STANDOUT   0200
#define   _NOCHANGE   -1

struct _win_st
{
  short _cury, _curx;
  short _maxy, _maxx;
  short _begy, _begx;
  short FG, BG, REV_FG, REV_BG;	/* colors */
  short _flags;
  bool _clear;
  bool _leave;
  bool _scroll;
  bool _touch;
  bool _keypad;
  bool _box;			/* TRUE if there's a box on the screen */
  short _fr, _lr;		/* first row, last row changed */
  char **_y;
};

#define   WINDOW   struct _win_st

bool My_term, _echoit, _rawmode, _endwin;

char *Def_term, *ttytype;

int LINES = 25, COLS = 80;
char PC, *BC, *UP, *_clstr, *_cmstr;
int ospeed;

WINDOW *stdscr;

/*
 * psuedo functions
 */

#define clearok(win,bf) (win->_clear = bf)
#define leaveok(win,bf) (win->_leave = bf)
#define scrollok(win,bf) (win->_scroll = bf)
#define keypad(win,bf) (win->_keypad = bf)
#define flushok(w,bf) (bf?(w->_flags|=_FLUSH):(w->_flags&=~_FLUSH))
#define getyx(win,y,x) y = win->_cury, x = win->_curx
#define winch(win) (*(*(win->_y+win->_cury)+win->_curx) & 0177)


WINDOW *initscr (), *newwin (), *subwin ();
char *longname ();

/*
 * Used to be in unctrl.h.
 */
#define   unctrl(c)   *(_unctrl+((c) & 0177))
extern char *_unctrl[];

#endif

char acs_map[] =
{
  '\00',			/* '\00' */
  '\01',			/* '\01' */
  '\02',			/* '\02' */
  '\03',			/* '\03' */
  '\04',			/* '\04' */
  '\05',			/* '\05' */
  '\06',			/* '\06' */
  '\07',			/* '\07' */
  '\010',			/* '\010' */
  '\011',			/* '\011' */
  '\012',			/* '\012' */
  '\013',			/* '\013' */
  '\014',			/* '\014' */
  '\015',			/* '\015' */
  '\016',			/* '\016' */
  '\017',			/* '\017' */
  '\020',			/* '\020' */
  '\021',			/* '\021' */
  '\022',			/* '\022' */
  '\023',			/* '\023' */
  '\024',			/* '\024' */
  '\025',			/* '\025' */
  '\026',			/* '\026' */
  '\027',			/* '\027' */
  '\030',			/* '\030' */
  '\031',			/* '\031' */
  '\032',			/* '\032' */
  '\033',			/* '\033' */
  '\034',			/* '\034' */
  '\035',			/* '\035' */
  '\036',			/* '\036' */
  '\037',			/* '\037' */
  '\040',			/* ' ' */
  '\041',			/* '!' */
  '\042',			/* '"' */
  '\043',			/* '#' */
  '\044',			/* '$' */
  '\045',			/* '%' */
  '\046',			/* '&' */
  '\047',			/* ''' */
  '\050',			/* '(' */
  '\051',			/* ')' */
  '\052',			/* '*' */
  '\032',			/* '+' */
  '\033',			/* ',' */
  '\030',			/* '-' */
  '\031',			/* '.' */
  '\057',			/* '/' */
  '\333',			/* '0' */
  '\061',			/* '1' */
  '\062',			/* '2' */
  '\063',			/* '3' */
  '\064',			/* '4' */
  '\065',			/* '5' */
  '\066',			/* '6' */
  '\067',			/* '7' */
  '\070',			/* '8' */
  '\071',			/* '9' */
  '\072',			/* ':' */
  '\073',			/* ';' */
  '\074',			/* '<' */
  '\075',			/* '=' */
  '\076',			/* '>' */
  '\077',			/* '?' */
  '\100',			/* '@' */
  '\101',			/* 'A' */
  '\102',			/* 'B' */
  '\103',			/* 'C' */
  '\104',			/* 'D' */
  '\105',			/* 'E' */
  '\106',			/* 'F' */
  '\107',			/* 'G' */
  '\110',			/* 'H' */
  '\111',			/* 'I' */
  '\112',			/* 'J' */
  '\113',			/* 'K' */
  '\114',			/* 'L' */
  '\115',			/* 'M' */
  '\116',			/* 'N' */
  '\117',			/* 'O' */
  '\120',			/* 'P' */
  '\121',			/* 'Q' */
  '\122',			/* 'R' */
  '\123',			/* 'S' */
  '\124',			/* 'T' */
  '\125',			/* 'U' */
  '\126',			/* 'V' */
  '\127',			/* 'W' */
  '\130',			/* 'X' */
  '\131',			/* 'Y' */
  '\132',			/* 'Z' */
  '\133',			/* '[' */
  '\134',			/* '\' */
  '\135',			/* ']' */
  '\136',			/* '^' */
  '\137',			/* '_' */
  '\004',			/* '`' */
  '\261',			/* 'a' */
  '\142',			/* 'b' */
  '\143',			/* 'c' */
  '\144',			/* 'd' */
  '\145',			/* 'e' */
  '\370',			/* 'f' */
  '\361',			/* 'g' */
  '\260',			/* 'h' */
  '\017',			/* 'i' */
  '\274',			/* 'j' */
  '\273',			/* 'k' */
  '\311',			/* 'l' */
  '\310',			/* 'm' */
  '\316',			/* 'n' */
  '\157',			/* 'o' */
  '\160',			/* 'p' */
  '\315',			/* 'q' */
  '\162',			/* 'r' */
  '\163',			/* 's' */
  '\314',			/* 't' */
  '\271',			/* 'u' */
  '\312',			/* 'v' */
  '\313',			/* 'w' */
  '\272',			/* 'x' */
  '\171',			/* 'y' */
  '\172',			/* 'z' */
  '\173',			/* '{' */
  '\174',			/* '|' */
  '\175',			/* '}' */
  '\007',			/* '~' */
  '\177',			/* '\177' */
  '\200',			/* '\200' */
  '\201',			/* '\201' */
  '\202',			/* '\202' */
  '\203',			/* '\203' */
  '\204',			/* '\204' */
  '\205',			/* '\205' */
  '\206',			/* '\206' */
  '\207',			/* '\207' */
  '\210',			/* '\210' */
  '\211',			/* '\211' */
  '\212',			/* '\212' */
  '\213',			/* '\213' */
  '\214',			/* '\214' */
  '\215',			/* '\215' */
  '\216',			/* '\216' */
  '\217',			/* '\217' */
  '\220',			/* '\220' */
  '\221',			/* '\221' */
  '\222',			/* '\222' */
  '\223',			/* '\223' */
  '\224',			/* '\224' */
  '\225',			/* '\225' */
  '\226',			/* '\226' */
  '\227',			/* '\227' */
  '\230',			/* '\230' */
  '\231',			/* '\231' */
  '\232',			/* '\232' */
  '\233',			/* '\233' */
  '\234',			/* '\234' */
  '\235',			/* '\235' */
  '\236',			/* '\236' */
  '\237',			/* '\237' */
  '\240',			/* '\240' */
  '\241',			/* '\241' */
  '\242',			/* '\242' */
  '\243',			/* '\243' */
  '\244',			/* '\244' */
  '\245',			/* '\245' */
  '\246',			/* '\246' */
  '\247',			/* '\247' */
  '\250',			/* '\250' */
  '\251',			/* '\251' */
  '\252',			/* '\252' */
  '\253',			/* '\253' */
  '\254',			/* '\254' */
  '\255',			/* '\255' */
  '\256',			/* '\256' */
  '\257',			/* '\257' */
  '\260',			/* '\260' */
  '\261',			/* '\261' */
  '\262',			/* '\262' */
  '\263',			/* '\263' */
  '\264',			/* '\264' */
  '\265',			/* '\265' */
  '\266',			/* '\266' */
  '\267',			/* '\267' */
  '\270',			/* '\270' */
  '\271',			/* '\271' */
  '\272',			/* '\272' */
  '\273',			/* '\273' */
  '\274',			/* '\274' */
  '\275',			/* '\275' */
  '\276',			/* '\276' */
  '\277',			/* '\277' */
  '\300',			/* '\300' */
  '\301',			/* '\301' */
  '\302',			/* '\302' */
  '\303',			/* '\303' */
  '\304',			/* '\304' */
  '\305',			/* '\305' */
  '\306',			/* '\306' */
  '\307',			/* '\307' */
  '\310',			/* '\310' */
  '\311',			/* '\311' */
  '\312',			/* '\312' */
  '\313',			/* '\313' */
  '\314',			/* '\314' */
  '\315',			/* '\315' */
  '\316',			/* '\316' */
  '\317',			/* '\317' */
  '\320',			/* '\320' */
  '\321',			/* '\321' */
  '\322',			/* '\322' */
  '\323',			/* '\323' */
  '\324',			/* '\324' */
  '\325',			/* '\325' */
  '\326',			/* '\326' */
  '\327',			/* '\327' */
  '\330',			/* '\330' */
  '\331',			/* '\331' */
  '\332',			/* '\332' */
  '\333',			/* '\333' */
  '\334',			/* '\334' */
  '\335',			/* '\335' */
  '\336',			/* '\336' */
  '\337',			/* '\337' */
  '\340',			/* '\340' */
  '\341',			/* '\341' */
  '\342',			/* '\342' */
  '\343',			/* '\343' */
  '\344',			/* '\344' */
  '\345',			/* '\345' */
  '\346',			/* '\346' */
  '\347',			/* '\347' */
  '\350',			/* '\350' */
  '\351',			/* '\351' */
  '\352',			/* '\352' */
  '\353',			/* '\353' */
  '\354',			/* '\354' */
  '\355',			/* '\355' */
  '\356',			/* '\356' */
  '\357',			/* '\357' */
  '\360',			/* '\360' */
  '\361',			/* '\361' */
  '\362',			/* '\362' */
  '\363',			/* '\363' */
  '\364',			/* '\364' */
  '\365',			/* '\365' */
  '\366',			/* '\366' */
  '\367',			/* '\367' */
  '\370',			/* '\370' */
  '\371',			/* '\371' */
  '\372',			/* '\372' */
  '\373',			/* '\373' */
  '\374',			/* '\374' */
  '\375',			/* '\375' */
  '\376',			/* '\376' */
  '\377',			/* '\377' */
  0
};

/*
 * Standard alternate character set.  The current ACS world is evolving, so
 * we support only a widely available subset: the line drawing characters
 * from the VT100, plus a few from the Teletype 5410v1.  Eventually there may
 * be support of more sophisticated ACS line drawing, such as that in the
 * Teletype 5410, the HP line drawing set, and the like.  There may be
 * support for some non line oriented characters as well.
 * 
 * Line drawing ACS names are of the form ACS_trbl, where t is the top, r is the
 * right, b is the bottom, and l is the left.  t, r, b, and l might be B
 * (blank), S (single), D (double), or T (thick).  The subset defined here
 * only uses B and S.
 */

#define ACS_BSSB	(acs_map['l'])
#define ACS_SSBB	(acs_map['m'])
#define ACS_BBSS	(acs_map['k'])
#define ACS_SBBS	(acs_map['j'])
#define ACS_SBSS	(acs_map['u'])
#define ACS_SSSB	(acs_map['t'])
#define ACS_SSBS	(acs_map['v'])
#define ACS_BSSS	(acs_map['w'])
#define ACS_BSBS	(acs_map['q'])
#define ACS_SBSB	(acs_map['x'])
#define ACS_SSSS	(acs_map['n'])

/*
 * Human readable names for the most commonly used characters. "Upper",
 * "right", etc. are chosen to be consistent with the vt100 manual.
 */

#define ACS_ULCORNER	ACS_BSSB
#define ACS_LLCORNER	ACS_SSBB
#define ACS_URCORNER	ACS_BBSS
#define ACS_LRCORNER	ACS_SBBS
#define ACS_RTEE	ACS_SBSS
#define ACS_LTEE	ACS_SSSB
#define ACS_BTEE	ACS_SSBS
#define ACS_TTEE	ACS_BSSS
#define ACS_HLINE	ACS_BSBS
#define ACS_VLINE	ACS_SBSB
#define ACS_PLUS	ACS_SSSS
#define ACS_S1		(acs_map['o'])	/* scan line 1 */
#define ACS_S9		(acs_map['s'])	/* scan line 9 */
#define ACS_DIAMOND	(acs_map['`'])	/* diamond */
#define ACS_CKBOARD	(acs_map['a'])	/* checker board (stipple) */
#define ACS_DEGREE	(acs_map['f'])	/* degree symbol */
#define ACS_PLMINUS	(acs_map['g'])	/* plus/minus */
#define ACS_BULLET	(acs_map['~'])	/* bullet */
/* Teletype 5410v1 symbols */
#define ACS_LARROW	(acs_map[','])	/* arrow pointing left */
#define ACS_RARROW	(acs_map['+'])	/* arrow pointing right */
#define ACS_DARROW	(acs_map['.'])	/* arrow pointing down */
#define ACS_UARROW	(acs_map['-'])	/* arrow pointing up */
#define ACS_BOARD	(acs_map['h'])	/* board of squares */
#define ACS_LANTERN	(acs_map['i'])	/* lantern symbol */
#define ACS_BLOCK	(acs_map['0'])	/* solid square block */

char *malloc ();
long time ();

/* graphic characters and variables for box() */

/*
 * GH = horizontal GV = vertical GUL = upper left-hand corner GUR = upper
 * right-hand corner GLL = lower left-hand corner GLR = lower right-hand
 * corner GLT = left-hand tee (like |- ) GRT = right-hand tee (like -| ) GUT
 * = upper tee (like T ) GDT = down (lower) tee (like upside-down T )
 */

struct dbox
{
  char GH, GV, GUL, GUR, GLL, GLR, GLT, GRT, GUT, GDT;
}    dbox;

/* for non-graphic supporting terminals */

char nonll[] =
{
  '-',
  '|',
  '+',
  '+',
  '+',
  '+',
  '+',
  '+',
  '+',
  '+'};

/* single line boxes */

char singlel[] =
{
  '\304',
  '\263',
  '\332',
  '\277',
  '\300',
  '\331',
  '\303',
  '\264',
  '\302',
  '\301'};

/* double line boxes */

char doublel[] =
{
  '\315',
  '\272',
  '\311',
  '\273',
  '\310',
  '\274',
  '\314',
  '\271',
  '\313',
  '\312'};

/* solid boxes */

char solidl[] =
{
  '\333',
  '\333',
  '\333',
  '\333',
  '\333',
  '\333',
  '\333',
  '\333',
  '\333',
  '\333'};

#ifdef MSDOS
union REGS inregs, outregs;

#endif

union ptr_union
{
  char *chr_p;
  unsigned int *uint_p;
  unsigned long *ulong_p;
};
static int ic;
static char *rnc_arg;
static rnc_code;

/* _doscanf and XXX are both PD routines */

_doscanf (code, funcarg, format, argp)
int code;
char *funcarg;
char *format;
union ptr_union *argp;
{
  int done = 0;
  int base;
  long val;
  int sign;
  int do_assign;
  unsigned width;
  int widflag;
  int longflag;
  int done_some;
  int reverse;
  char *endbracket;

  rnc_arg = funcarg;
  rnc_code = code;

  rnc ();

  if (ic == EOF)
  {
    done = EOF;
    goto quit;
  }

  while (1)
  {
    while (iswhite (*format))
      ++format;
    if (!*format)
      goto all_done;
    if (ic < 0)
      goto quit;
    if (*format != '%')
    {
      while (iswhite (ic))
	rnc ();
      if (ic != *format)
	goto all_done;
      ++format;
      rnc ();
      ++done;
      continue;
    }
    ++format;
    do_assign = 1;
    if (*format == '*')
    {
      ++format;
      do_assign = 0;
    }
    if (isdigit (*format))
    {
      widflag = 1;
      for (width = 0; isdigit (*format);)
	width = width * 10 + *format++ - '0';
    }
    else
      widflag = 0;
    if (longflag = (tolower (*format) == 'l'))
      ++format;
    if (*format != 'c')
      while (iswhite (ic))
	rnc ();
    done_some = 0;
    switch (*format)
    {
    case 'o':
      base = 8;
      goto decimal;
    case 'u':
    case 'd':
      base = 10;
      goto decimal;
    case 'x':
      base = 16;
      if (((!widflag) || width >= 2) && ic == '0')
      {
	rnc ();
	if (tolower (ic) == 'x')
	{
	  width -= 2;
	  done_some = 1;
	  rnc ();
	}
	else
	{
	  ugc ();
	  ic = '0';
	}
      }
    decimal:
      val = 0L;
      sign = 0;
      if (!widflag)
	width = 0xffff;
      if (width && ic == '+')
	rnc ();
      else if (width && ic == '-')
      {
	sign = 1;
	rnc ();
      }
      while (width--)
      {
	if (isdigit (ic) && ic - '0' < base)
	  ic -= '0';
	else if (base == 16 && tolower (ic) >= 'a' && tolower (ic) <= 'f')
	  ic = 10 + tolower (ic) - 'a';
	else
	  break;
	val = val * base + ic;
	rnc ();
	done_some = 1;
      }
      if (do_assign)
      {
	if (sign)
	  val = -val;
	if (longflag)
	  *(argp++)->ulong_p = (unsigned long) val;
	else
	  *(argp++)->uint_p = (unsigned) val;
      }
      if (done_some)
	++done;
      else
	goto all_done;
      break;
    case 'c':
      if (!widflag)
	width = 1;
      while (width-- && ic >= 0)
      {
	if (do_assign)
	  *(argp)->chr_p++ = (char) ic;
	rnc ();
	done_some = 1;
      }
      if (do_assign)
	argp++;
      if (done_some)
	++done;
      break;
    case 's':
      if (!widflag)
	width = 0xffff;
      while (width-- && !iswhite (ic) && ic > 0)
      {
	if (do_assign)
	  *(argp)->chr_p++ = (char) ic;
	rnc ();
	done_some = 1;
      }
      if (do_assign)
	*(argp++)->chr_p = '\0';
      if (done_some)
	++done;
      else
	goto all_done;
      break;
    case '[':
      if (!widflag)
	width = 0xffff;

      if (*(++format) == '^')
      {
	reverse = 1;
	format++;
      }
      else
	reverse = 0;

      endbracket = format;
      while (*endbracket != ']' && *endbracket != '\0')
	endbracket++;

      if (!*endbracket)
	goto quit;

      *endbracket = '\0';

      while (width-- && !iswhite (ic) && ic > 0 &&
	     (indexin (ic, format) ^ reverse))
      {
	if (do_assign)
	  *(argp)->chr_p++ = (char) ic;
	rnc ();
	done_some = 1;
      }
      format = endbracket;
      *format = ']';
      if (do_assign)
	*(argp++)->chr_p = '\0';
      if (done_some)
	++done;
      else
	goto all_done;
      break;
    }
    ++format;
  }
all_done:
  if (ic >= 0)
    ugc ();
quit:
  return done;
}

int
box (win, v, h)
WINDOW *win;
char v, h;
{
  char userbox[11];
  int sx, sy, i;

  switch (cur_box)
  {
  case 0:
    sprintf (userbox, "%c%c%c%c%c%c%c%c%c%c",
	     h, v, h, h, h, h, h, h, v, v);
    memcpy (&dbox.GH, userbox, 10);
    break;

  case 1:
    memcpy (&dbox.GH, nonll, 10);
    break;

  case 2:
    memcpy (&dbox.GH, singlel, 10);
    break;

  case 3:
    memcpy (&dbox.GH, doublel, 10);
    break;

  case 4:
    memcpy (&dbox.GH, solidl, 10);
    break;
  }

  sx = win->_curx;
  sy = win->_cury;
  mvwaddch (win, 0, 0, ACS_ULCORNER);
  mvwaddch (win, 0, win->_maxx, ACS_URCORNER);
  mvwaddch (win, win->_maxy, 0, ACS_LLCORNER);
  mvwaddch (win, win->_maxy, win->_maxx, ACS_LRCORNER);
  wmove (win, 0, 1);
  for (i = 1; i < win->_maxx; i++)
    waddch (win, ACS_HLINE);
  wmove (win, win->_maxy, 1);
  for (i = 1; i < win->_maxx; i++)
    waddch (win, ACS_HLINE);
  for (i = 1; i < win->_maxy; i++)
  {
    mvwaddch (win, i, 0, ACS_VLINE);
    mvwaddch (win, i, win->_maxx, ACS_VLINE);
  }
  win->_curx = sx;
  win->_cury = sy;
  win->_box = TRUE;
  return (OK);
}

int
delwin (win)
WINDOW *win;
{

  int i;

  for (i = 0; i < win->_maxy + 1; i++)
    free (*(win->_y + i));
  free (win->_y);
  free (win);
  return (OK);
}

int
endwin ()
{

  int i;

  delwin (stdscr);
  return (OK);
}

int
getmode (mode, cols, page)
int *mode, *cols, *page;
{
#ifdef MSDOS
  inregs.h.ah = 15;
  int86 (0x10, &inregs, &outregs);
  *mode = outregs.h.al;
  *cols = outregs.h.ah;
  *page = outregs.h.bh;
#endif
  return (OK);
}

indexin (ch, string)
char ch;
char *string;
{
  while (*string++ != ch)
    if (!*string)
      return 0;
  return 1;
}

WINDOW *
initscr ()
{
  char *tt, *scr;

  if (time ((long *) 0) > ~EXPDATE)
  {
    puts ("Your license to use the curses package has expired.");
    exit (1);
  }
  _curwin = 0;
#ifdef MSDOS
  mode80c ();
#else
  if ((tt = getenv ("TERM")) == (char *) EOF)
  {
    puts ("initscr: need $TERM set!");
    exit (1);
  }
  switch (tgetent ((char *) NULL, tt))
  {
  case 0:
    puts ("terminal type not in termcap database!");
    exit (1);
    break;

  case -1:
    puts ("termcap database unreadable!");
    exit (1);
    break;

  default:
    break;
  }
  if ((LINES = tgetnum ("li")) == EOF)
  {
    puts ("number of lines not defined!");
    exit (1);
  }
  if ((COLS = tgetnum ("co")) == EOF)
  {
    puts ("number of columns not defined!");
    exit (1);
  }

  /*
   * get PC, UP, and BC capabilities
   */
  scr = tgetstr ("pc", (char **) NULL);
  if (scr == (char *) EOF)
    PC = NULL;
  else
    PC = *scr;
  ospeed = tgetnum ("pb");
  BC = tgetstr ("le", (char **) NULL);
  UP = tgetstr ("up", (char **) NULL);
  _cmstr = tgetstr ("cm", (char **) NULL);
  _clstr = tgetstr ("cl", (char **) NULL);
#endif
  /* loadkybd ((char *) NULL); */
  if (!(stdscr = newwin (LINES, COLS, 0, 0)))
    return ((WINDOW *) ERR);
  return ((WINDOW *) OK);
}

char *
longname (termbuf, name)
char *termbuf, *name;
{
#ifdef MSDOS
  return ("vt100");
#else
  return (getenv ("TERM"));
#endif
}

#ifdef MSDOS
int
mode80c ()			/* change mode to 80 col color/bw */
{
  struct SREGS segregs;
  int mode, cols, page;
  char v;

  segread (&segregs);
  _wind0 = 0xb800;
  getmode (&mode, &cols, &page);
  COLS = cols;
  _retrace = 0;
  int86 (0x11, &inregs, &outregs);
  if (0x30 == (outregs.x.ax & 0x30))
  {
    _wind0 = 0xb000;
    return (OK);
  }

  /*
   * movedata(0x0040, 0x0087, segregs.ds, &v, 1); if(v == 0) _retrace = 1;
   */

  inregs.h.ah = 0;
  inregs.h.al = (COLS == 80 ? 3 : 1);
  int86 (0x10, &inregs, &outregs);
  return (OK);
}
#endif

int
mvcur (oldrow, oldcol, row, col)
int oldrow, oldcol, row, col;
{
  char rrow, ccol;

  if (row > LINES)
    return (ERR);
  if (col > COLS)
    return (ERR);
  rrow = row;
  ccol = col;
#ifdef MSDOS
  inregs.h.ah = 2;
  inregs.h.dh = rrow & 0x1f;
  inregs.h.dl = ccol & 0x7f;
  inregs.h.bh = 0;
  int86 (0x10, &inregs, &outregs);
#else
  tgoto (_cmstr, row, col);
#endif
  return (OK);
}

int
mvwin (win, y, x)
WINDOW *win;
int y, x;
{
  if (y > (LINES - 1) || x > (COLS - 1))
    return (ERR);
  if (y > (win->_begy + win->_maxy))
    return (ERR);
  if (x > (win->_begx + win->_maxx))
    return (ERR);
  win->_begy = y;
  win->_begx = x;
  touchwin (win);
  return (OK);
}

WINDOW *
newwin (endy, endx, y, x)
int endy, endx, y, x;
{
  WINDOW *win;
  int i;

  if (endy == 0)
    endy = LINES - y;
  if (endx == 0)
    endx = COLS - y;

  if (!(win = (WINDOW *) malloc (sizeof (WINDOW))))
    return (ERR);

  if (!(win->_y = (char **) malloc ((endy + 1) * sizeof (char *))))
         return (ERR);

  for (i = 0; i < (endy + 1); i++)
    if ((*(win->_y + i) = malloc (2 * ((endx + 1)))) == (char *) 0)
      return (ERR);
  win->_cury = 0;
  win->_curx = 0;
  win->_begy = y;
  win->_begx = x;
  win->_maxy = endy - 1;
  win->_maxx = endx - 1;
  win->FG = 7;
  win->BG = 0;
  win->REV_FG = 0;
  win->REV_BG = 7;
  clearok (win, TRUE);
  leaveok (win, FALSE);
  scrollok (win, FALSE);
  keypad (win, FALSE);
  win->_fr = 1 + win->_maxy;
  win->_lr = -1;
  win->_flags = 0;
  win->_box = FALSE;		       /* no box on the screen */
  wclear (win);
  return (win);
}

int
overlay (win1, win2)
WINDOW *win1, *win2;
{
  int i, j, maxx, maxy;
  int overlay = 1;		/* 1 if this is overlay, 0 if it's overwrite */

  maxx = (win1->_maxx > win2->_maxx ? win2->_maxx : win1->_maxx);
  maxy = (win1->_maxy > win2->_maxy ? win2->_maxy : win1->_maxy);

  for (i = 0; i < maxy + 1; i++)
  {
    for (j = 0; j < maxx + 1; j++)
    {
      /* don't copy if it's a blank */
      if (overlay == 1 && *(*(win1->_y + i) + j * 2) == ' ')
	continue;
      *(*(win2->_y + i) + (j * 2)) = *(*(win1->_y + i) + (j * 2));
      *(*(win2->_y + i) + (j * 2) + 1) = *(*(win1->_y + i) + (j * 2) + 1);
    }
  }
}
int
overwrite (win1, win2)
WINDOW *win1, *win2;
{
  int i, j, maxx, maxy;
  int overlay = 0;		/* 1 if this is overlay, 0 if it's overwrite */

  maxx = (win1->_maxx > win2->_maxx ? win2->_maxx : win1->_maxx);
  maxy = (win1->_maxy > win2->_maxy ? win2->_maxy : win1->_maxy);

  for (i = 0; i < maxy + 1; i++)
  {
    for (j = 0; j < maxx + 1; j++)
    {
      /* don't copy if it's a blank */
      if (overlay == 1 && *(*(win1->_y + i) + (j * 2)) == ' ')
	continue;
      *(*(win2->_y + i) + (j * 2)) = *(*(win1->_y + i) + (j * 2));
      *(*(win2->_y + i) + (j * 2) + 1) = *(*(win1->_y + i) + (j * 2) + 1);
    }
  }
}
int
printw (va_alist)
va_dcl
{
  char pf[512];
  va_list args;
  char *fmt;
  int ret;

  va_start (args);
  fmt = va_arg (args, char *);

  ret = vsprintf (pf, fmt, args);
  addstr (pf);
  va_end (args);
  return (ret);
}

rnc ()
{
  if (rnc_code)
  {
    if (!(ic = *rnc_arg++))
      ic = EOF;
  }
  else
    ic = getc ((FILE *) rnc_arg);
}

int
scanw (format, args)
char *format;
unsigned args;
{
  char *sb[512];

  getstr (sb);
  return _doscanf (1, sb, format, &args);
}

int
scroll (win)
WINDOW *win;
{
#ifdef MSDOS
  inregs.h.ah = 6;
  inregs.h.al = 1;
  inregs.h.bh = (char) ((win->FG & 0x0f) | ((win->BG & 0x0f) << 4));
  if (win->_box == TRUE)
  {
    inregs.h.ch = win->_begy + 1;
    inregs.h.cl = win->_begx + 1;
    inregs.h.dh = win->_begy + win->_maxy - 1;
    inregs.h.dl = win->_begx + win->_maxx - 1;
  }
  else
  {
    inregs.h.ch = win->_begy;
    inregs.h.cl = win->_begx;
    inregs.h.dh = win->_begy + win->_maxy;
    inregs.h.dl = win->_begx + win->_maxx;
  }
  int86 (0x10, &inregs, &outregs);
#endif
}

#ifdef MSDOS
int
sleep (n)
int n;
{
  long secs, secsave;
  long time ();

  secsave = time ((long *) 0);
  while (0 != ((secsave + n) - (time ((long *) 0))))
    kbhit ();
  return (0);
}

int
switchsc (screen)
int screen;
{
  inregs.h.ah = 5;
  inregs.h.al = screen;
  int86 (0x10, &inregs, &outregs);
  return (OK);
}
#endif

int
touchwin (win)
WINDOW *win;
{
  win->_fr = 0;
  win->_lr = win->_maxy;
  return (OK);
}

ugc ()
{
  if (rnc_code)
    --rnc_arg;
  else
    ungetc (ic, (FILE *) rnc_arg);
}

int
waddch (win, c)
WINDOW *win;
char c;
{
  int sx;
  char attrib;

  /*
   * if(win->FG != FG) win->FG = FG; if(win->BG != BG) win->BG = BG;
   * if(win->REV_FG != REV_FG) win->REV_FG = REV_FG; if(win->REV_BG !=
   * REV_BG) win->REV_BG = REV_BG;
   */
  attrib = (char) ((win->FG & 0x0f) | ((win->BG & 0x0f) << 4));

  if (c == '\r')
  {
    win->_curx = 0;
    return (OK);
  }
  if (c == '\b')
  {
    win->_curx--;
    if (win->_curx < 0)
      win->_curx = 0;
    return (OK);
  }
  if (c == '\n')
  {
    sx = win->_curx;
    while (win->_curx < 1 + win->_maxx)
    {
      *(*(win->_y + win->_cury) + (2 * win->_curx)) = ' ';
      *(*(win->_y + win->_cury) + (1 + (2 * win->_curx))) = attrib;
      win->_curx++;
    }
    if (NEWMAP == 1)
      win->_curx = 0;
    else
      win->_curx = sx;
    win->_cury++;
    if (win->_cury > win->_maxy)
    {
      win->_cury--;
      return (ERR);

      /*
       * if (win->_scroll == FALSE) { win->_curx = 0; return (ERR); } else {
       * scroll (win); win->_curx = 0; return (OK); }
       */
    }
    return (OK);
  }
  if (win->_cury > win->_maxy)
  {
    win->_cury--;
    if (win->_scroll == FALSE)
    {
      win->_curx = 0;
      return (ERR);
    }
    else
    {
      scroll (win);
      win->_curx = 0;
      return (OK);
    }
  }
  *(*(win->_y + win->_cury) + (2 * win->_curx)) = c;
  *(*(win->_y + win->_cury) + 1 + (2 * win->_curx)) = attrib;
  win->_curx++;
  if (win->_curx > win->_maxx)
  {
    win->_curx = 0;
    win->_cury++;
  }
  if (win->_cury > win->_maxy)
  {
    win->_cury--;
    if (win->_scroll == FALSE)
    {
      win->_curx = 0;
      return (ERR);
    }
    else
    {
      scroll (win);
      win->_curx = 0;
      return (OK);
    }
  }
  if (win->_cury < win->_fr)
    win->_fr = win->_cury;
  if (win->_cury > win->_lr)
    win->_lr = win->_cury;
  return (OK);
}

int
waddstr (win, s)
WINDOW *win;
char *s;
{
  int i, sx;

  while (*s != (char) 0)
  {
    if (*s == '\t')
    {
      sx = win->_curx;
      for (i = 0; i < 1 + (sx % 8); i++)
	waddch (win, ' ');
      continue;
    }
    if (ERR == waddch (win, *s))
      return (ERR);
    s++;
  }
  return (OK);
}

int
wclear (win)
WINDOW *win;
{
  int y, x;

  win->_curx = 0;
  win->_cury = 0;
  for (y = 0; y < win->_maxy + 1; y++)
  {
    for (x = 0; x < win->_maxx + 1; x++)
    {
      waddch (win, ' ');
    }
  }
  win->_curx = 0;
  win->_cury = 0;
  clearok (win, TRUE);
  win->_box = FALSE;
  return (OK);
}

int
wclrtobot (win)
WINDOW *win;
{
  int y, x, sx, sy;

  sx = win->_curx;
  sy = win->_cury;

  while (win->_curx != win->_maxx)
    waddch (win, ' ');
  for (y = win->_cury; y < win->_maxy + 1; y++)
    for (x = 0; x != win->_maxx; x++)
      waddch (win, ' ');
  win->_curx = sx;
  win->_cury = sy;
  return (OK);
}

int
wclrtoeol (win)
WINDOW *win;
{
  int y, x, sx, sy;

  sx = win->_curx;
  sy = win->_cury;
  while (win->_curx != win->_maxx)
    waddch (win, ' ');
  win->_curx = sx;
  win->_cury = sy;
  return (OK);
}

int
wcolor (win, f, b, rf, rb)
WINDOW *win;
int f, b, rf, rb;
{
  if (f != EOF)
    win->FG = f;
  if (b != EOF)
    win->BG = b;
  if (rf != EOF)
    win->REV_FG = rf;
  if (rb != EOF)
    win->REV_BG = rb;
}

int
wdelch (win)
WINDOW *win;
{
  int x, sx;

  sx = win->_curx;

  for (x = win->_curx; x < win->_maxx + 1; x++)
  {
    *(*(win->_y + win->_cury) + 2 * x) = *(*(win->_y + win->_cury) + 2 * (x + 1));
    *(*(win->_y + win->_cury) + 2 * x + 1) = *(*(win->_y + win->_cury) + 2 * (x + 1) + 1);
  }
  win->_curx = win->_maxx;
  waddstr (win, ' ');
  win->_curx = sx;
  return (OK);
}

int
wdeleteln (win)
WINDOW *win;
{
  int i, sx, sy;
  char *save, saveline[512];

  sx = win->_curx;
  sy = win->_cury;
  win->_fr = win->_cury;
  win->_lr = win->_maxy;
  win->_curx = 0;
  save = *(win->_y + win->_cury);
  for (i = 0; i < COLS * 2; i++)
    *(*(win->_y + win->_cury) + i) = *(*(win->_y + win->_maxy) + i);
  for (i = 1 + win->_cury; i < win->_maxy + 1; i++)
    *(win->_y + (i - 1)) = *(win->_y + i);
  win->_cury = win->_maxy;
  for (i = 0; i < win->_maxx + 1; i++)
    waddch (win, ' ');
  *(win->_y + (win->_maxy - 1)) = save;
  win->_curx = sx;
  win->_cury = sy;
}

int
werase (win)
WINDOW *win;
{
  wclear (win);
  clearok (win, FALSE);
  return (OK);
}

int
wgetch (win)
WINDOW *win;
{
  int c;

  /*
   * do keypad stuff here
   */
  c = getchar ();
#ifdef MSDOS
  if (c == 0 || c == 0xE0)
    c = 128 + (0x7f & getch ());
#endif
  if (ECHOSW)
  {
    waddch (win, c);
    wrefresh (win);
  }
  return (c);
}

int
wgetstr (win, s)
WINDOW *win;
char *s;
{
  char c;
  int pos = 0, x, y;

  while ((c = wgetch (win)) != 13)
  {
    if (c == 8)
    {
      c = NULL;
      pos--;
      if (pos < 0)
      {
	pos = 0;
	puts ("\7");
      }
      else
      {
	*s = NULL;
	s--;
	if (ECHOSW)
	{
	  getyx (win, y, x);
	  x--;
	  move (y, x);
	  waddch (' ');		       /* destructive backspace */
	  move (y, x);
	  wrefresh (win);
	}
      }
    }
    else
    {
      *s++ = c;
      pos++;
    }
  }
  *s = NULL;
  return (OK);
}

int
winsch (win, c)
WINDOW *win;
char c;
{
  int sx, x;

  sx = win->_curx;

  for (x = win->_curx; x < win->_maxx; x++)
  {
    *(*(win->_y + win->_cury) + (2 * (x + 1))) = *(*(win->_y + win->_cury) + (2 * x));
    *(*(win->_y + win->_cury) + (2 * (x + 1)) + 1) = *(*(win->_y + win->_cury) + (2 * x + 1));
  }
  win->_curx = sx;
  waddstr (win, c);
  win->_curx = sx;
  return (OK);
}

int
winsertln (win)
WINDOW *win;
{
  int i, sx, sy;
  char *save;

  sx = win->_curx;
  sy = win->_cury;
  win->_fr = win->_cury;
  win->_lr = win->_maxy;
  save = *(win->_y + win->_maxy);
  for (i = win->_maxy - 1; i != win->_cury - 1; i--)
    *(win->_y + (i + 1)) = *(win->_y + i);
  win->_curx = 0;
  win->_cury = sy;
  *(win->_y + sy) = save;
  for (i = 0; i < win->_maxx + 1; i++)
    waddch (win, ' ');
  win->_curx = sx;
  win->_cury = sy;
}

int
wmove (win, y, x)
WINDOW *win;
int y, x;
{
  if (y > win->_maxy || x > win->_maxx)
    return (ERR);
  win->_cury = y;
  win->_curx = x;
  return (OK);
}

int
wprintw (va_alist)
va_dcl
{
  char pf[512];
  va_list args;
  char *fmt;
  WINDOW *win;
  int ret;

  va_start (args);
  win = va_arg (args, WINDOW *);
  fmt = va_arg (args, char *);

  ret = vsprintf (pf, fmt, args);
  waddstr (win, pf);
  va_end (args);
  return (ret);
}

int
wrefresh (win)
WINDOW *win;
{
  register int i;

#ifdef MSDOS
  struct SREGS segregs;
  unsigned int ds;

  segread (&segregs);
  ds = segregs.ds;
#endif
  mvcur (0, 0, win->_cury + win->_begy, win->_curx + win->_begx);
  if (win->_fr > win->_maxy)
    return (OK);
  for (i = win->_fr; i < win->_lr + 1; i++)
#ifdef MSDOS

    /*
     * if (_retrace) movsdata(ds, *(win->_y + i), _wind0, (_count * _curwin)
     * + (2 * (((win->_begy + i) * COLS) + win->_begx)), 2 * (win->_maxx +
     * 1)); else
     */
    movedata (ds, *(win->_y + i), _wind0,
	(_count * _curwin) + (2 * (((win->_begy + i) * COLS) + win->_begx)),
	      2 * (win->_maxx + 1));
#else
    
#endif
  win->_fr = 1 + win->_maxy;
  win->_lr = -1;
  return (OK);
}

int
wscanw (win, format, args)
WINDOW *win;
char *format;
unsigned args;
{
  char *sb[512];

  wgetstr (win, sb);
  return _doscanf (1, sb, format, &args);
}

int
wstandend (win)
WINDOW *win;
{
  short t;

  if ((win->_flags & _STANDOUT) != _STANDOUT)
    return (NULL);
  win->_flags &= ~_STANDOUT;
  t = win->BG;
  win->BG = win->REV_BG;
  win->REV_BG = t;
  t = win->FG;
  win->FG = win->REV_FG;
  win->REV_FG = t;

  /*
   * FG     = savefg ; BG     = savebg ; REV_FG = saverfg; REV_BG = saverbg;
   */
  return (OK);
}

int
wstandout (win)
WINDOW *win;
{
  short t;

  if ((win->_flags & _STANDOUT) == _STANDOUT)
    return (NULL);

  /*
   * if(win->FG != FG) win->FG = FG; if(win->BG != BG) win->BG = BG;
   * if(win->REV_FG != REV_FG) win->REV_FG = REV_FG; if(win->REV_BG !=
   * REV_BG) win->REV_BG = REV_BG;
   */
  win->_flags |= _STANDOUT;
  t = win->BG;
  win->BG = win->REV_BG;
  win->REV_BG = t;
  t = win->FG;
  win->FG = win->REV_FG;
  win->REV_FG = t;

  /*
   * savefg = FG; savebg = BG; saverfg = REV_FG; saverbg = REV_BG; FG =
   * win->FG; BG = win->BG; REV_FG = win->REV_FG; REV_BG = win->REV_BG;
   */
  return (OK);
}
/*
 * getkchar - get function/arrow key(s), translate them to an integer
 * according to the key mappings in curses.h.  This assumes that zap() has
 * already been called to fill in sstrs and sflags.
 * 
 * Written 01/93 by Ed Carp (erc@apple.com) - Copyright 1993, by Ed Carp
 * 
 * The algorithm is like this:  We allocate a bitmap array, zero it, then for
 * each character we get, we scan sstrs[*][0].  If we don't get a match, we
 * simply return the character.  If we do, we save away the character and
 * bump sstrs[*].  On the first non-match for each sstrs, we zero out that
 * particular bitmap.  If the bitmap gets to zero, we return the first
 * character in the saved array and set a flag.  On each subsequent call of
 * getkchar, if the flag is set, we simply return the characters out of the
 * array until empty, then reset the flag.
 * 
 * If we reach the end of all sstrs[*] and bitmap isn't zero, we have a match.
 * We clear the saved array, make sure the flag isn't set, then look up the
 * appropriate code to return and return that.
 * 
 * Yes, it's not the fastest or most elegant way to do it, but hey, it works.
 */

/*
 * Externals for cr_tty.c and getkchar.c
 * 
 * I broke them out because both cr_tty.c and getkchar.c are impacted by changes
 * here.
 * 
 * -- Ed Carp (erc@apple.com)
 */

static bool *sflags[] =
{
  &AM, &BS, &DA, &DB, &EO, &HC, &HZ, &IN, &MI,
  &MS, &NC, &NS, &OS, &UL, &XB, &XN, &XT, &XS,
  &XX
};

static char *_PC, **sstrs[] =
{
  &AL, &BC, &BT, &CD, &CE, &CL, &CM, &CR, &CS,
  &DC, &DL, &DM, &DO, &ED, &EI, &K0, &K1, &K2,
  &K3, &K4, &K5, &K6, &K7, &K8, &K9, &HO, &IC,
  &IM, &IP, &KD, &KE, &KH, &KL, &KR, &KS, &KU,
  &LL, &MA, &ND, &NL, &_PC, &RC, &SC, &SE, &SF,
  &SO, &SR, &TA, &TE, &TI, &UC, &UE, &UP, &US,
  &VB, &VS, &VE, &AL_PARM, &DL_PARM, &UP_PARM,
  &DOWN_PARM, &LEFT_PARM, &RIGHT_PARM,
  &AK1, &AK2, &AK3, &AK4, &AK5, &KB, &KDC, &KEND, &KI,
  &KNP, &KPP, &KEND, &AS, &AE
};

#include "acs_map.h"
char _tspace[2048];		/* Space for capability strings */
int k_flag;
static char k_array[64];
static int k_ctr, k_lim;
int
getkchar ()
{
  int c, i, j, k, k_longest, k_temp, k_found;
  int k_intctr = 0, k_bitmap[(sizeof (sstrs) / sizeof (*sstrs)) + 1];
  char *ptr;

  if (k_flag && k_ctr < k_lim)
  {
#ifdef DEBUG
    fprintf (outf, "GETKCHAR: k_flag set, Returning '%c' (0x%x)\n",
	     *(k_array + k_ctr), *(k_array + k_ctr));
    fflush (outf);
#endif
    k_ctr++;
    return (*(k_array + k_ctr - 1));
  }
  k_flag = k_ctr = k_lim = 0;	       /* reset flag */
#ifdef DEBUG
  fprintf (outf, "GETKCHAR: sizeof sstrs=%d, *sstrs=%d, **sstrs=%d, ***sstrs=%d\n",
      sizeof (sstrs), sizeof (*sstrs), sizeof (**sstrs), sizeof (***sstrs));
  fflush (outf);
#endif
  /* scan the array for the longest member */
  k_longest = 0;
  for (i = 0; i < sizeof (sstrs) / sizeof (*sstrs); i++)
  {
    k_bitmap[i] = 1;
#ifdef DEBUG
    fprintf (outf, "GETKCHAR: Scanning *sstrs[%d]=%s\n", i, *sstrs[i]);
    fflush (outf);
#endif
    if ((k_temp = strlen (*sstrs[i])) > k_longest)
      k_longest = k_temp;
  }
#ifdef DEBUG
  fprintf (outf, "GETKCHAR: scanned %d, k_longest=%d\n", i, k_longest);
  fflush (outf);
#endif
  for (j = 0; j < k_longest; j++)
  {
    k_found = 0;
    c = getchar ();
    if (c == 0xa && j == 0)
      c = 0xd;			       /* remap */
#ifdef DEBUG
    fprintf (outf, "GETKCHAR: looking for #%d - c=%c (0x%x)\n", k_ctr + 1, c, c);
    fflush (outf);
#endif
    k_array[k_ctr++] = c;
    for (i = 0; i < sizeof (sstrs) / sizeof (*sstrs); i++)
    {
      if (k_bitmap[i] == 0)
      {
#ifdef DEBUG
	fprintf (outf, "GETKCHAR: (1) Skipping invalid bitmap member %d\n", i);
	fflush (outf);
#endif
	continue;		       /* skip invalid members */
      }

      /*
       * We have a valid member at this point.  See if it's still valid.
       */
      ptr = *sstrs[i];
      if (ptr == (char *) NULL)
      {
#ifdef DEBUG
	fprintf (outf, "GETKCHAR: (2) Skipping invalid bitmap member %d\n", i);
	fflush (outf);
#endif
	k_bitmap[i] = 0;
	continue;
      }
      if (*ptr == (int) NULL)
      {
#ifdef DEBUG
	fprintf (outf, "GETKCHAR: (3) Skipping invalid bitmap member %d\n", i);
	fflush (outf);
#endif
	k_bitmap[i] = 0;
	continue;
      }
#ifdef DEBUG
      fprintf (outf, "GETKCHAR: Assigning *sstrs[%d]=%s\n", i, *sstrs[i]);
      fflush (outf);
      fprintf (outf, "GETKMAP: Checking to see if ptr[%d] %c (0x%x) == %c (0x%x)\n",
	       j, ptr[j], ptr[j], c, c);
      fflush (outf);
#endif
      if (ptr[j + 1] == 0 && k_bitmap[i] == 1 /* && j > 0 */  && ptr[j] == c)
      {

	/*
	 * We have a match!  Return the appropriate code
	 */
#ifdef DEBUG
	fprintf (outf, "GETKMAP: ptr[%d] %c (0x%x) == %c (0x%x) (matched %s)\n",
		 j, ptr[j], ptr[j], c, c, ptr);
	fflush (outf);
	fprintf (outf, "GETKMAP: Yup.  We also have a string match!\n");
	fprintf (outf, "GETKMAP: Returning (code %d) %d (0%o)\n",
		 i, k_code[i], k_code[i]);
	fflush (outf);
#endif
	return (k_code[i]);
      }
      if (ptr[j] != c)
      {
#ifdef DEBUG
	fprintf (outf, "GETKMAP: Nope.\n");
	fflush (outf);
#endif
	k_bitmap[i] = 0;	       /* nope */
	continue;		       /* next member */
      }
      k_found = 1;
#ifdef DEBUG
      fprintf (outf, "GETKMAP: ptr[%d] %c (0x%x) == %c (0x%x)\n",
	       j, ptr[j], ptr[j], c, c);
      fflush (outf);
      fprintf (outf, "GETKMAP: Yup.\n");
      fflush (outf);
#endif
    }
    if (k_found != 1)
    {
      k_flag = 1;
      k_lim = k_ctr;
      k_ctr = 1;
#ifdef DEBUG
      fprintf (outf, "GETKMAP: Returning k_array[0] ('%c') (0x%x).\n", c, c);
      fflush (outf);
#endif
      return (k_array[0]);
    }
  }
}

wattron (win, fl)
WINDOW *win;
long fl;
{
  switch (fl)
  {
  case A_ALTCHARSET:
    wrefresh (win);
    _puts (AS);
    wrefresh (win);
    refresh ();
    break;
  case A_NORMAL:
    wrefresh (win);
    _puts (AE);
    wrefresh (win);
    refresh ();
    break;
  }
}
